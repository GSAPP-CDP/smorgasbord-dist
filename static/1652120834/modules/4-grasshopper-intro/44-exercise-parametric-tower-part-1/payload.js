__NUXT_JSONP__("/modules/4-grasshopper-intro/44-exercise-parametric-tower-part-1", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S){return {data:[{path:y,_img:{}}],fetch:{"data-v-13708080:0":{module:{slug:"4-4-exercise-parametric-tower-part-1",moduleid:44,title:z,published:true,authors:["Danil Nagy"],toc:[{id:A,depth:p,text:B},{id:C,depth:p,text:D},{id:E,depth:p,text:F},{id:G,depth:p,text:H},{id:I,depth:p,text:J},{id:K,depth:p,text:L}],body:{type:"root",children:[{type:b,tag:v,props:{id:"exercise---parametric-tower-part-1"},children:[{type:b,tag:i,props:{href:"#exercise---parametric-tower-part-1",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:z}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-1.gif"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"In this tutorial, we will construct a tower model controlled by a set of parameters in Grasshopper. In this first of four exercises, we will focus on the basic form of the tower."}]},{type:a,value:c},{type:b,tag:q,props:{id:A},children:[{type:b,tag:i,props:{href:"#step-1-design-concept-and-strategy",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:B}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"As with any design process, when approaching a new computational design problem it is useful to spend some time thinking through the problem you are trying to solve and formulating a concept and approach to guide your design process. Most Grasshopper tutorials only focus on the "},{type:b,tag:w,props:{},children:[{type:a,value:"what"}]},{type:a,value:" of computational design, with step-by-step instructions describing the process of building a particular model. This can teach you some useful tools and approaches but misses the critical points of "},{type:b,tag:w,props:{},children:[{type:a,value:"how"}]},{type:a,value:" to think about design problems computationally, and "},{type:b,tag:w,props:{},children:[{type:a,value:"why"}]},{type:a,value:" we might want to do this in the first place."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"When formulating a concept for your model, a good approach is to first sketch what you want to achieve and then “reverse engineer” it to figure out how to build it. In this case, I want to create a twisting tower with parameters to control the amount of twist as well as the height of the tower and the shape of the floors. I can start by sketching out what I think a twisting tower might look like. Don’t spend too long on these sketches, they don’t need to be especially detailed or of high artistic quality. Nonetheless, they are important for getting a rough understanding of what you want to build so that you have a good strategy for how to start in Grasshopper."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-2.png"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Once I have a basic design approach in mind, I can start to break it down into components to develop a strategy for building the model. Looking at the sketches I can observe that the twisting effect comes from having similar shape floors that rotate relative to each other as they go up the building."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Based on this observation, I can develop a strategy for building the model in Grasshopper. For example, I might first figure out how to create one floor, then copy the floor multiple times vertically, adding a small rotation to every copy. Of course, you will need to adjust your strategy while you build the model based on what you find works and doesn’t work, but starting with an initial visual concept and strategy will make the process of starting a model much easier."}]},{type:a,value:c},{type:b,tag:q,props:{id:C},children:[{type:b,tag:i,props:{href:"#step-2-define-the-base-point",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:D}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"As we saw in the previous "},{type:b,tag:i,props:{href:"https:\u002F\u002Fmedium.com\u002Fintro-to-grasshopper\u002Fexercise-hello-grasshopper-c3cd53dd19d5",rel:[M,N,O],target:P},children:[{type:a,value:"tutorial"}]},{type:a,value:", a good place to start a model is with a base point that defines a point in space relative to which we can start defining the rest of our geometry."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-3.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Last time we used a "},{type:b,tag:d,props:{},children:[{type:a,value:"Point"}]},{type:a,value:" component to define the point in the Rhino viewport. This time, let’s use a "},{type:b,tag:d,props:{},children:[{type:a,value:"Construct Point"}]},{type:a,value:" component to build the point directly in Grasshopper. This component has three numerical inputs representing the X, Y, and Z coordinates of the point in 3-d space. Each of these inputs has a default value of 0, which means that when you first place the component on the canvas it will create a point at (0,0,0) or the model’s origin. If you want to move the point somewhere else you can input a "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:Q},{type:b,tag:d,props:{},children:[{type:a,value:"Panel"}]},{type:a,value:" with a numerical value into any of the inputs. For now, let’s keep the defaults to leave our base point at the origin."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-4.gif"},children:[]}]},{type:a,value:c},{type:b,tag:q,props:{id:E},children:[{type:b,tag:i,props:{href:"#step-3-model-the-first-floor",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:F}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Once we have a base point to locate our tower, we need to define the shape of the first floor. Based on the sketch, I want something curvy and not rotationally symmetric so I get the twisting effect when I rotate the floors relative to each other. I will choose to model my floors with an ellipse but feel free to experiment with other shapes as well."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-5.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"To create the ellipse we can use the "},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:" component, which creates an ellipse based on a center point and two numbers that define its radius in both directions. Let’s connect the base point we just created to the (P) input and connect two new "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" components to the two radius inputs."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-6.png"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Here is a useful shortcut for creating "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" components: double-click anywhere on the canvas to bring up the search menu and type any number in the search bar. This will create a "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" component set to that number. The decimal places you use in the number controls the decimal resolution of the slider. By default, the range of the slider will go from 0 to the closest power of 10 to the number. You can also set the range yourself by typing the minimum and maximum values, along with the number, in the format "},{type:b,tag:d,props:{},children:[{type:a,value:"min\u003Cnumber\u003Cmax"}]},{type:a,value:". For example, typing in "},{type:b,tag:d,props:{},children:[{type:a,value:"0\u003C25\u003C50"}]},{type:a,value:" will produce a number slider with the range 0–50, set to 25."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-7.gif"},children:[]}]},{type:a,value:c},{type:b,tag:q,props:{id:G},children:[{type:b,tag:i,props:{href:"#step-4-create-more-floors",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:H}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Now that we’ve built one floor, we can multiply it vertically to create the other floors. In Rhino we would do this with the Copy or Array command. In Grasshopper, things work a little differently. Each component on the Grasshopper canvas runs individually, and stores the data it produces in its outputs. Even if that data is then passed on to one or more components downstream, the original data produced by a component will always remain within that component. This means that objects created by one component cannot be directly modified by another component, but only used for generating its own outputs."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-8.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"The persistence of data in the canvas means that Grasshopper does not need separate components for copying or arraying objects. Instead, you can use the "},{type:b,tag:d,props:{},children:[{type:a,value:o}]},{type:a,value:" component to translate the object one or more times, and then hide the original object if you don’t want to see it in the Rhino viewport."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"The "},{type:b,tag:d,props:{},children:[{type:a,value:o}]},{type:a,value:" component has two inputs: the geometry (G) you want to move and a translation vector (T) that describes the magnitude and direction of the move. We’ll discuss Vectors in more detail in the "},{type:b,tag:i,props:{href:R},children:[{type:a,value:"next lesson"}]},{type:a,value:", so you can follow along for now or skip ahead if you’d like more background."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Create a new "},{type:b,tag:d,props:{},children:[{type:a,value:o}]},{type:a,value:" component and place it to the right of the "},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:" component on the canvas. To specify the geometry, connect the ellipse created in the (E) output of the "},{type:b,tag:d,props:{},children:[{type:a,value:x}]},{type:a,value:" component to the "},{type:b,tag:d,props:{},children:[{type:a,value:o}]},{type:a,value:" component’s (G) input."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-9.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"To specify the direction of the move, we will use a "},{type:b,tag:d,props:{},children:[{type:a,value:r}]},{type:a,value:" component to create a new vector pointing in the model’s vertical Z direction. If you look in the ‘Vector’ section of the Vector tab of the component toolbar you will see that there is one Unit Vector component for each of the three coordinate axes. Place a new "},{type:b,tag:d,props:{},children:[{type:a,value:r}]},{type:a,value:" component on the canvas and connect its (V) output to the (T) input of the "},{type:b,tag:d,props:{},children:[{type:a,value:o}]},{type:a,value:S}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"You should now see a copy of the ellipse appear one unit length above the original ellipse. The Unit Vector components have one input (F) which controls the magnitude of the vector. This input has a default value of 1.0, so by default these components create vectors of one unit magnitude (such vectors are called unit vectors)."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-10.png"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Since the magnitude of the vector will control how much the ellipse is moved, it should be based on the height of each floor. But we don’t want to only create one floor. We want the "},{type:b,tag:d,props:{},children:[{type:a,value:o}]},{type:a,value:" component to run multiple times, creating a new ellipse each time and moving it vertically to its proper location. To do this we will first create a "},{type:b,tag:"list",props:{},children:[{type:a,value:" of values representing the height of each floor, and then pass this List to the "},{type:b,tag:d,props:{},children:[{type:a,value:r}]},{type:a,value:" component to create a set of vectors to move all the ellipses into place."}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-11.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"A quick way to generate a set of evenly spaced numbers is with the "},{type:b,tag:d,props:{},children:[{type:a,value:s}]},{type:a,value:" component (we will review these more in the "},{type:b,tag:"next",props:{lesson:R},children:[{type:a,value:"). This component creates a set of sequential numbers based on three inputs — the starting value (S), the step or increment between each value (N), and the number of values to generate (C)."}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"We will keep the default starting value of 0.0 so our first floor stays in the same place as the original curve. Let’s create two new "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" components to control the other two inputs. The step size controls the distance between each height value, so the first "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" component will set the floor-to-floor height of the building. The number of values we want to generate is based on the number of floors we want to create, so the second "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" component will control the total number of floors in the building. You can rename the "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" components so you remember what they control by right-clicking on them and changing the name at the top of the context menu."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-12.png"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Connect the (S) output of the "},{type:b,tag:d,props:{},children:[{type:a,value:s}]},{type:a,value:" component to the (F) input of the "},{type:b,tag:d,props:{},children:[{type:a,value:r}]},{type:a,value:" component to generate the floors of the tower. We now have a simple tower definition based on four parameters. You can slide the "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" components one by one to get a feel for how they control the model in real-time."}]},{type:a,value:c},{type:b,tag:q,props:{id:I},children:[{type:b,tag:i,props:{href:"#step-5-lets-twist",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:J}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"To create the twist in our tower, we will apply a rotation to each of the ellipses. First, let’s use another "},{type:b,tag:d,props:{},children:[{type:a,value:s}]},{type:a,value:" component to generate a list of numbers representing the rotation angles of each floor. Since we need one rotation value for each floor, we should reuse the same "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" component that specified the number of floors previously for the (C) inputs of both "},{type:b,tag:d,props:{},children:[{type:a,value:s}]},{type:a,value:" components in our model. This way, if we want to change the number of floors in the future, all we have to do is change one "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" component and everything will update correctly. Reusing input data within your model is good practice for making robust models and minimizing the chance of bugs later on."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-13.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Once the rotation values are generated, we can use them to rotate our ellipses using the "},{type:b,tag:d,props:{},children:[{type:a,value:t}]},{type:a,value:" component. Create a new "},{type:b,tag:d,props:{},children:[{type:a,value:t}]},{type:a,value:" component on the canvas and connect the ellipses to its (G) input and the angle values to its (A) input. In Grasshopper, angles are usually expected to be in radians. If you’d prefer to work in degrees, you can pass the values through the "},{type:b,tag:d,props:{},children:[{type:a,value:"Radian"}]},{type:a,value:" component first to convert the degrees to radians, and then pass the resulting radian values to the "},{type:b,tag:d,props:{},children:[{type:a,value:t}]},{type:a,value:S}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-14.gif"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Because the original non-rotated ellipses are still stored in the "},{type:b,tag:d,props:{},children:[{type:a,value:o}]},{type:a,value:" component, you will probably see the new rotated Ellipses overlapping them in the Rhino viewport. At this point, it may be useful to start hiding the outputs of some of the earlier components to create a cleaner visualization of the final result."}]},{type:a,value:c},{type:b,tag:q,props:{id:K},children:[{type:b,tag:i,props:{href:"#step-6-give-it-solid-form",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:L}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"The last step of this exercise is to create the solid volumes of the building by extruding each ellipse vertically based on the building’s floor-to-floor height."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-15.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"To extrude the ellipses we can use the "},{type:b,tag:d,props:{},children:[{type:a,value:u}]},{type:a,value:" component. This component has two inputs: one for the Curve you want to extrude, and one for the Vector that describes the magnitude and direction of the extrusion. Create a new "},{type:b,tag:d,props:{},children:[{type:a,value:u}]},{type:a,value:" component and connect its (B) input to the (G) output of the "},{type:b,tag:d,props:{},children:[{type:a,value:t}]},{type:a,value:" component which is storing the rotated ellipses."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"To define the direction of extrusion for each curve, let’s use another "},{type:b,tag:d,props:{},children:[{type:a,value:r}]},{type:a,value:" component. Connect its (F) input to the "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" component we created previously to control the floor-to-floor height and it’s output to the (D) input of the "},{type:b,tag:d,props:{},children:[{type:a,value:u}]},{type:a,value:" component. Since we are connecting multiple curves but only one vector, the same vector will be reused for each extrusion, which is fine since all the floors of the building have the same height."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-16.png#img-left"},children:[]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"At this point, you should see a stack of ribbons defining the shape of the tower. The last step is to create the lower and upper surface of each volume by passing the result of the "},{type:b,tag:d,props:{},children:[{type:a,value:u}]},{type:a,value:" component into a "},{type:b,tag:d,props:{},children:[{type:a,value:"Cap"}]},{type:a,value:" component. This component will fill in any planar holes in a "},{type:b,tag:d,props:{},children:[{type:a,value:"Surface"}]},{type:a,value:Q},{type:b,tag:d,props:{},children:[{type:a,value:"Polysurface"}]},{type:a,value:" object. Once the top and bottom holes are capped, we will have one closed Brep or Polysurface object defining the volume of each floor in the tower."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-17.png"},children:[]}]},{type:a,value:c},{type:b,tag:v,props:{id:"conclusion"},children:[{type:b,tag:i,props:{href:"#conclusion",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:"Conclusion"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"In this exercise, we defined the basic twisting form of the parametric tower. The five "},{type:b,tag:d,props:{},children:[{type:a,value:h}]},{type:a,value:" components we created while building the model can now be used to control the various parameters of the tower. Spend some time experimenting with the parameters and see what kind of different tower shapes you can create. In case you got lost along the way, you can download a finished version of the demo "},{type:b,tag:i,props:{href:"https:\u002F\u002Fwww.dropbox.com\u002Fs\u002F44ohfz1qxjzrymx\u002Fintro-to-gh_tower_1.gh?dl=1",rel:[M,N,O],target:P},children:[{type:a,value:"here"}]},{type:a,value:"."}]},{type:a,value:c},{type:b,tag:v,props:{id:"challenge"},children:[{type:b,tag:i,props:{href:"#challenge",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:"CHALLENGE:"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"We built our simple parametric tower definition based on elliptical floors. What if we wanted rectangular floors instead? The beauty of Grasshopper is that once you define your model’s logic once, it should be relatively easy to make changes by replacing certain aspects of the model while keeping the rest of the logic intact. Try replacing the Ellipse component with one or more other components to change the shape of the floors while keeping the rest of the tower definition the same. What kind of interesting towers can you create by combining the twist operation with floors of different shapes?"}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:b,tag:f,props:{alt:g,src:"images\u002F4-4-18.gif"},children:[]}]}]},dir:"\u002Fmodules\u002F4-grasshopper-intro",path:y,extension:".md",createdAt:"2022-04-08T22:08:13.054Z",updatedAt:"2022-04-08T22:08:13.055Z"}},"data-v-9c60a860:0":{_error:{message:"Cannot read property 'forEach' of undefined",statusCode:500}}},mutations:[]}}("text","element","\n","code","p","content-img","description","Number Slider","a","true",-1,"span","icon","icon-link","Move",3,"h3","Unit Z","Series","Rotate","Extrude","h1","em","Ellipse","\u002Fmodules\u002F4-grasshopper-intro\u002F44-exercise-parametric-tower-part-1","Exercise - Parametric tower (part 1)","step-1-design-concept-and-strategy","Step 1: Design concept and strategy","step-2-define-the-base-point","Step 2: Define the base point","step-3-model-the-first-floor","Step 3: Model the first floor","step-4-create-more-floors","Step 4: Create more floors","step-5-lets-twist","Step 5: Let’s twist","step-6-give-it-solid-form","Step 6: Give it (solid) form","nofollow","noopener","noreferrer","_blank"," or ",""," component.")));